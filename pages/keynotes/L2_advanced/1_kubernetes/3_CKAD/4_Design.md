---
title: 设计Kubernetes资源
keywords: keynotes, L2_advanced, 1_kubernetes, 3_CKAD, 4_Design
permalink: keynotes_L2_advanced_1_kubernetes_3_CKAD_4_Design.html
sidebar: keynotes_L2_advanced_sidebar
typora-copy-images-to: ./pics/4_Design
typora-root-url: ../../../../../../cloudnative365.github.io

---

## 1. 课程目标

+ 定义一个应用的资源清单
+ 理解多容器Pod的设计模式：sidecar，adapter，ambassador
+ 讨论应用设计的概念

## 2. 设计Kubernetes资源

### 2.1. 传统应用架构

在生产系统中实现Kubernetes最大的障碍就是要根据现有的应用环境去设计。最佳的Kubernetes部署的设计比简单的容器化一个应用要复杂的多。在传统的应用构建和部署的时候，进程之间的耦合性旺旺非常强。

比如，Apache网站服务基本不允许一些定制化的功能。所以，服务器本身和应用被无缝的绑在了一起。随着需求的增加，应用会被迁移到更大的服务器上。我们假设构建和维护服务器的时候，实例必须不能停止，并且他和其他资源（存储和网络）也高度的集成。

在早期的容器使用当中，应用在容器化的时候，是不需要重新部署的。这就到这了资源在失败之后，升级之后或者重新配置之后的一些问题。费用和重新设计的时候的一些意见分歧，还有重新部署的成本都需要考虑进去

### 2.2. 资源的解耦

资源的解耦对于Kubernetes是必须要做的事情。在某个实例的整个生命周期中，应用不使用专用的端口和套接字，这么做的目的就是为了让每个功能和他依赖的资源解耦。软件的整个期望向着每个组件都可以被移除，代替或者重新构建整个目标靠拢。

我们一般不会把某个资源写死在一个应用里面，我们会用调度的资源，就好像Service，启用链接和重新链接的方式来提供更灵活的服务。独立的机器已经不能满足应用和用户的需求了，特定数量的系统需要整合在一起来满足特定的需求。

随着Kubernetes的逐渐成熟，有更多的资源被开发出来，这些资源也非常容易的被部署。同时，kubernetes的开发者也在优化特定的功能，使得我们在设计的时候不用过多考虑其他的对象。

### 2.3. 临时性

与解耦同样重要的是临时性。我们希望有新的功能上线的时候，其他的组件不会也因为这个组件的更新而意外终止，或者需要重新构建。所有的资源对于其他资源的调用都应该是一次性的，这样的话我们就可以轻松的升级版本或者横向扩展。

直接升级并不一定是最好的选择，因为没法保证剩下的应用是可用的。控制器通常会终止一个容器，然后去部署一个新的容器去取代原来的位置，当然，新的容器是和原来容器不一样的版本或者设置。通常，传统的应用都不是用这种方式开发的，没有为长远的设计而考虑。

### 2.4. 灵活的架构

就像是一群鱼，或者可以想象成一个pod的鲸鱼，很多独立的资源在一起工作，但是彼此是不会相互影响的，而且永远不会依赖其他的鲸鱼，这样就是灵活的，高可用的，和容易扩展的。不使用巨大的apache服务器，我们可以部署很多灵活的nginx服务器，每个都处理一小部分的请求。这样同样可以达到目的，并且设计的好处是使得每个nginx处理的请求都不相同。

一个解耦的，灵活的，而且临时性的框架并不是最效率的。为了让Kubernetes的编排功能起作用，我们需要一些的agents，就想控制器，或者是一个守护进程，他持续的监控目前集群的状态和做变更，直到状态满足我们的要求。

目前硬件的商业趋势是使用多个小型的服务器来代替一个巨大的系统。

### 2.5. 管理资源的使用

怎样限制节点的CPU，内存和root文件系统存储的使用